<!-- TOC -->

- [1. 输入输出和标准名字空间](#1-输入输出和标准名字空间)
    - [1.1 标准输入](#11-标准输入)
    - [1.2 标准输出](#12-标准输出)
    - [1.3 标准名字空间](#13-标准名字空间)
- [2. 数据类型](#2-数据类型)
    - [2.1 字符串](#21-字符串)
    - [2.2 类型转换](#22-类型转换)
        - [2.2.1 隐式类型转换](#221-隐式类型转换)
        - [2.2.2 强制类型转换](#222-强制类型转换)
- [3. 函数](#3-函数)
    - [3.1 函数重载](#31-函数重载)
    - [3.2 内联函数](#32-内联函数)
- [4. 动态内存分配](#4-动态内存分配)
    - [4.1 new动态分配内存](#41-new动态分配内存)
    - [4.2 delete释放内存](#42-delete释放内存)
- [5. 引用](#5-引用)
    - [5.1 概念](#51-概念)
    - [5.2 与指针的比较](#52-与指针的比较)
    - [5.3 常引用](#53-常引用)
- [6. 类Class](#6-类class)
    - [6.1 控制访问属性](#61-控制访问属性)
    - [6.2 类的多文件编译](#62-类的多文件编译)
    - [6.3 构造函数](#63-构造函数)
        - [6.3.1 构造函数的重载和缺省构造函数](#631-构造函数的重载和缺省构造函数)
        - [6.3.2 自定义类型转换构造函数](#632-自定义类型转换构造函数)
        - [6.3.3 拷贝构造函数](#633-拷贝构造函数)
        - [6.3.4 初始化列表](#634-初始化列表)
    - [6.4 this指针](#64-this指针)
    - [6.5 const成员函数和mutable关键字](#65-const成员函数和mutable关键字)
    - [6.6 析构函数](#66-析构函数)
    - [6.7 拷贝赋值函数](#67-拷贝赋值函数)
    - [6.8 static成员](#68-static成员)
        - [6.8.1 static成员变量](#681-static成员变量)
        - [6.8.2 static成员函数](#682-static成员函数)
        - [6.8.3 单例模式](#683-单例模式)
    - [6.9 运算符重载](#69-运算符重载)
- [7. 继承](#7-继承)
    - [7.1 继承特性](#71-继承特性)
    - [7.2 子类相关函数](#72-子类相关函数)
    - [7.3 多重继承和虚析构](#73-多重继承和虚析构)
    - [7.4 多态](#74-多态)
    - [7.5 虚析构](#75-虚析构)
    - [7.6 纯虚函数和抽象类](#76-纯虚函数和抽象类)
- [8. 异常](#8-异常)
- [9. I/O流](#9-io流)

<!-- /TOC -->
# 1. 输入输出和标准名字空间
## 1.1 标准输入 
>cin >> a >> b; //scanf("%d%d\n",&a,&b);

## 1.2 标准输出 
>cout << a << b << endl; //printf("%d%d\n",a,b);

**endl类似'\n'。**

## 1.3 标准名字空间
1. **std::** 表示标准名字空间，使用**namespace**关键字定义名字空间。
2. 名字空间成员可以是全局变量，函数，类型，名字空间：
>namespace 名字空间名字{<br>
    int g_num=0; // 全局变量<br> 
    void fun(){} // 函数<br>
    struct Student{}; //结构体类型<br>
    namespace 名字空间{} // 名字空间嵌套<br>
}
3. 使用名字空间指令，可以全局使用名字空间里的成员，调用成员时，不需要显示声明**std::**。
>using namespace 名字空间名字;

# 2. 数据类型
## 2.1 字符串 
1. 初始化：
    >- string s1 = "hello world";
    >- string s2(s1);
2. 获取字符串长度：
    >- size_t size();//长度不包含'\0'
    >- size_t lenght();//本质和上面一样
3. 转换为C风格的字符串：
    >- const char* c_str();
4. 交换字符串：
    >- void swap(string s1,string s2);

## 2.2 类型转换 
### 2.2.1 隐式类型转换 
C++支持隐式类型转换，即由小转大。

### 2.2.2 强制类型转换
1. 静态类型转换：<br>
用于隐式转换的逆转换，常用于将void*转换为其它类型的指针。
>目标类型变量 = static_cast<目标类型>(源类型变量);
2. 常量类型转换：<br>
主要用于去除指针/引用上面的常量属性。
>目标类型变量 = const_cast<目标类型>(源类型变量);
3. 重解释类型转换：<br>
主要用于任意指针类型之间的转换，以及指针和整型之间的转换。
>目标类型变量 = reinterpret_cast<目标类型>(源类型变量);
4. 动态类型转换：<br>
主要用于具有多态特征的父子类指针/引用之间的转换。
>目标类型变量 = dynamic_cast<目标类型>(源类型变量);

# 3. 函数
## 3.1 函数重载
在同一个作用域内，函数名字相同，函数参数列表不同，这样的函数构成重载，与返回值类型无关。
1. 函数名相同，参数类型不同。
2. 函数名相同，参数个数不同。
3. 函数名相同，参数顺序不同。
4. 函数名相同，const修饰和非const修饰。

## 3.2 内联函数
1. 使用**inline**关键字修饰的函数叫内联函数。
2. 编译器将会尝试进行内联优化，用已编译好的二进制代码，替换对该函数的调用指令。
3. 效率和过程和宏函数有点像，与宏函数不同的是发生在编译阶段，不是预处理阶段。
4. 内联函数使可执行文件的体积和进程代码内存变大，**以空间换时间。**
5. 频繁调用的简单函数适合内联，稀少调用的复杂函数不适合内联。
6. **递归函数和虚函数不能内联。**
7. 内联函数是一种请求，最终是否内联，由编译器决定。

# 4. 动态内存分配
## 4.1 new动态分配内存
>int* pi = new int(66);

new数组：
>int* parr = new int[3]{1,2,3};

new对象：
>对象名* pclass = new 对象名(参数);<br>
>Student* p = new Student("张三");

new对象数组：
>对象名* pclass = new 对象名[3];<br>
>Student* parr = new Student[2]{Student("张三"),Student("李四")};

## 4.2 delete释放内存
不能通过delete操作符释放已释放过的内存。
>delete pi;<br>
>pi = NULL;

delete数组：
>delete[] parr;<br>
>parr = NULL;

# 5. 引用
## 5.1 概念
引用就是给变量起别名，引用可以做函数的参数和返回值。
>int a = 66;<br>
>int &b = a;<br>
>cout << b << endl;

## 5.2 与指针的比较
1. 引用必须初始化，指针可以不初始化。
2. 引用不可以为空，指针可以。
3. 引用不可以更换目标，指针可以。
4. 不能声明引用数组，可以声明指针数组。
5. 可以定义指向指针的指针，不能定义指向引用的指针。
6. 可以定义指针的引用，不能定义引用的引用。

## 5.3 常引用
>const int& a = b;<br>
>int const& a = b;//和上面等价

普通引用叫做左值引用，**常引用是万能引用**。<br>
普通引用指向右值(rvalue)会报错，如：
>int& r = 100;//报错

用const不会报错：
>const int& r = 100;

# 6. 类Class
## 6.1 控制访问属性
1. 不同的访问属性，影响类中成员访问的位置：
    - public，任何位置都可以访问。
    - protected，类内部和子类中可以访问。
    - private，只有类的内部才可以访问。
2. 缺省访问属性：
    - 使用class定义的类，缺省访问属性是private。
    - 使用struct定义的类，缺省访问属性是public。
    
## 6.2 类的多文件编译
类的声明和实现可以分开：<br>
**声明文件：**
>class Student{<br>
public:<br>
    &emsp;Student(const string& name, int age);<br>
    &emsp;void who();<br>
private:<br>
    &emsp;string m_name;<br>
    &emsp;int m_age;<br> 
};

**实现文件：**
>void Student::who(){<br>
    &emsp;cout << m_name << endl;<br>
}

**在实现文件中，要用类名::的方式限定作用域。**

## 6.3 构造函数
### 6.3.1 构造函数的重载和缺省构造函数
1. 一个函数名和类名完全相同，并且没有返回值（连void都没有）的函数叫做构造函数。
2. 对象创建时，系统自动调用。
3. 如果一个类中没有构造函数，系统会自动提供一个**缺省的无参构造函数。**
4. 构造函数可以重载，**即一个类中可以有多个构造函数**，参数不同。
>class Student{<br>
public:<br>
    &emsp;Student(void){}<br>
    &emsp;Student(const string& name, int age)<br>
    &emsp;{<br>
        &emsp;&emsp;m_name = name;<br>
        &emsp;&emsp;m_age = age;<br>
    &emsp;}<br>
private:<br>
    &emsp;string m_name;<br>
    &emsp;int m_age;<br>
};

### 6.3.2 自定义类型转换构造函数
1. 可以实现从源对象到目标对象的一个隐式转换。
2. **explicit关键字**可以告诉编译器，不支持隐式转换，必须使用显式转换。
>Student(const Person& person){}<br>

### 6.3.3 拷贝构造函数
1. 调用拷贝构造函数的时机：
    - 用已定义对象作为同类型对象的构造实参。
    - 以对象的形式向函数传递参数。
    - 从函数中返回对象（有时候会因编译优化而省略）。
2. 本质上还是一个构造函数，只是函数的参数是一个本类。
3. 如果没有显示定义拷贝构造函数，则会有个缺省拷贝函数。
4. **尽量避免或减少对象的拷贝，传递参数和返回值尽量使用引用。**
>Student(const Student& that){}<br>

### 6.3.4 初始化列表
1. **只有构造函数有初始化列表。**
2. 成员变量的初始化顺序和初始化列表中的顺序无关，而是取决于成员变量的声明顺序。
3. 初始化列表的必要性：
    - 如果类中包含常量或者引用的成员变量时。
    - 在子类中，显示的构造其基类部分。
>Student(const String& name,int age):m_name(name),m_age(age){}

## 6.4 this指针
1. 类的每个成员函数（包括构造函数，析构函数）都有一个隐藏的指针型参数this，指向调用该成员函数的对象。
2. 从成员函数中返回调用对象自身（返回自引用），支持串联调用。**（重点掌握）**
>class Counter{<br>
public:<br>
    &emsp;Counter(void){}<br>
    &emsp;Counter& add()<br>
    &emsp;{<br>
        &emsp;&emsp;m_count++;<br>
        &emsp;&emsp;return *this;<br>
    &emsp;}<br>
private:<br>
    &emsp;int m_count;<br>
};<br><br>
int main(){<br>
    &emsp;Counter c;<br>
    &emsp;c.add().add();<br>
}

## 6.5 const成员函数和mutable关键字
1. 在成员函数的形参表之后，函数体之前加上const关键字，即为常函数。
>void Student::getName()const{}
2. **常函数中的this指针是常指针，所以不能在常函数中修改成员变量。**
>void Student::getName()const{}//编译前<br>
>void Student::getName(const Student* this){}//编译后
3. **被声明为mutable的成员变量可以在const成员函数中被修改。**
>mutable int m_age(){}
4. const成员函数和非const成员函数构成重载。

## 6.6 析构函数
1. 当一个对象在销毁时会自动调用一个函数，这个函数名和类名相同（前面拥有～），函数没有参数和返回值，这样的函数是析构函数
>～Student(void){}
2. **因为没有参数，所以不能构成重载。**
3. 如果类中没有自定义析构函数，那么系统会自动提供一个缺省构造函数，该析构函数会自动调用成员变量基类的析构函数，即：<br>
假设有A和B类，A类作为B类的成员变量，则先构造A，再构造B，再析构B，再析构A。

## 6.7 拷贝赋值函数
1. 拷贝赋值函数**不是构造函数。**
>Student& operator=(const Student& s){<br>
    &emsp;if(&s != this){}//防止自赋值<br>
}
2. 如果类中没有自定义拷贝赋值运算符函数，那么系统会自动提供一个缺省拷贝赋值函数。

## 6.8 static成员
### 6.8.1 static成员变量
1. 同一个类可以创建多个对象，每个对象都分别有一份自己的成员，内存上各自独立，互不相干，但很多适合希望某个成员可以为所有对象共有，内存唯一，这样可以实现数据共享。
2. 在传统的C语言中，可以通过全局变量实现数据共享，在程序的任何位置可以访问全局变量，但是全局变量安全性得不到保证，随处都可以修改全局变量，不利于程序的维护。
3. C++希望通过一个被局限在类中使用的全局资源，来实现该类所以对象的数据共享。
4. 被static修饰的变量即为静态成员变量：
>class Student{<br>
>static int a;<br>
}
5. **static成员变量必须在类外部单独定义：**
>int Student::a=0;<br>
6. 静态成员变量属于类，非静态成员变量属于对象，**即可以把静态成员变量理解为限制在类中使用的全局变量。**
7. **sizeof计算类的大小时，不包括静态成员变量的大小。**

### 6.8.2 static成员函数
1. **静态成员函数没有this指针，**因为static中的变量任何对象都可以共享，所以没有固定地址。
2. **静态成员函数只能访问静态成员（因为没有this指针，不能访问普通的成员变量和函数）。**
3. 非静态成员函数可以访问静态成员变量。
4. **静态成员函数没有this指针，所有没有const属性**，不能用const修饰。

### 6.8.3 单例模式
这个类只能实例化一个对象。
>class Single{<br>
private://1. 私有化构造函数，不允许用户通过类创建类对象<br>
    &emsp;Single(){};<br>
    &emsp;Single(const Single& s){};<br>
    &emsp;Single& operatpr=(const Single& s){};<br>
private:<br>
    &emsp;//2. 加上static表示这只是静态变量的声明，所以编译器不会报错<br>
    &emsp;static Single s_sig;<br>
public://3. 声明静态函数，可以不需要创建对象就可以访问单例对象<br>
    &emsp;static Single getSingle(void){<br>
        &emsp;&emsp;return s_sig;<br>
    &emsp;}<br>
};<br>
Single::s_sig;//在类外面定义<br><br>
int main(){<br>
    &emsp;Single s1 = Single::getSingle();<br>
    &emsp;Single s2 = Single::getSingle();//上下两个变量地址一样，也就是只有一个对象。<br>
}

## 6.9 运算符重载

# 7. 继承
## 7.1 继承特性
1. 继承方式有public，protected，private，**一般开发都采用public继承方式**：
>class Student:public Person{}<br>
2. **如果在子类定义一个与基类同名的函数，子类中的函数会隐藏基类的函数。**

## 7.2 子类相关函数

## 7.3 多重继承和虚析构

## 7.4 多态

## 7.5 虚析构

## 7.6 纯虚函数和抽象类

# 8. 异常

# 9. I/O流