<!-- TOC -->

- [1. 输入输出和标准名字空间](#1-输入输出和标准名字空间)
    - [1.1 标准输入](#11-标准输入)
    - [1.2 标准输出](#12-标准输出)
    - [1.3 标准名字空间](#13-标准名字空间)
- [2. 数据类型](#2-数据类型)
    - [2.1 字符串](#21-字符串)
    - [2.2 类型转换](#22-类型转换)
        - [2.2.1 隐式类型转换](#221-隐式类型转换)
        - [2.2.2 强制类型转换](#222-强制类型转换)
- [3. 函数](#3-函数)
    - [3.1 函数重载](#31-函数重载)
    - [3.2 内联函数](#32-内联函数)
- [4. 动态内存分配](#4-动态内存分配)
    - [4.1 new动态分配内存](#41-new动态分配内存)
    - [4.2 delete释放内存](#42-delete释放内存)
- [5. 引用](#5-引用)
    - [5.1 概念](#51-概念)
    - [5.2 与指针的比较](#52-与指针的比较)
- [6. 面向对象](#6-面向对象)
    - [6.1 控制访问属性](#61-控制访问属性)
    - [6.2 构造函数](#62-构造函数)
    - [6.3 析构函数](#63-析构函数)
    - [6.4 this指针](#64-this指针)
- [7. 异常](#7-异常)
- [8. I/O流](#8-io流)

<!-- /TOC -->
# 1. 输入输出和标准名字空间
## 1.1 标准输入 
>cin >> a >> b; //scanf("%d%d\n",&a,&b);

## 1.2 标准输出 
>cout << a << b << endl; //printf("%d%d\n",a,b);

**endl类似'\n'。**

## 1.3 标准名字空间
1. **std::** 表示标准名字空间，使用**namespace**关键字定义名字空间。
2. 名字空间成员可以是全局变量，函数，类型，名字空间：
>namespace 名字空间名字{<br>
    int g_num=0; // 全局变量<br> 
    void fun(){} // 函数<br>
    struct Student{}; //结构体类型<br>
    namespace 名字空间{} // 名字空间嵌套<br>
}
3. 使用名字空间指令，可以全局使用名字空间里的成员，调用成员时，不需要显示声明**std::**。
>using namespace 名字空间名字;

# 2. 数据类型
## 2.1 字符串 
1. 初始化：
    >- string s1 = "hello world";
    >- string s2(s1);
2. 获取字符串长度：
    >- size_t size();//长度不包含'\0'
    >- size_t lenght();//本质和上面一样
3. 转换为C风格的字符串：
    >- const char* c_str();
4. 交换字符串：
    >- void swap(string s1,string s2);

## 2.2 类型转换 
### 2.2.1 隐式类型转换 
C++支持隐式类型转换，即由小转大。

### 2.2.2 强制类型转换
1. 静态类型转换：<br>
用于隐式转换的逆转换，常用于将void*转换为其它类型的指针。
>目标类型变量 = static_cast<目标类型>(源类型变量);
2. 常量类型转换：<br>
主要用于去除指针/引用上面的常量属性。
>目标类型变量 = const_cast<目标类型>(源类型变量);
3. 重解释类型转换：<br>
主要用于任意指针类型之间的转换，以及指针和整型之间的转换。
>目标类型变量 = reinterpret_cast<目标类型>(源类型变量);
4. 动态类型转换：<br>
主要用于具有多态特征的父子类指针/引用之间的转换。
>目标类型变量 = dynamic_cast<目标类型>(源类型变量);

# 3. 函数
## 3.1 函数重载
在同一个作用域内，函数名字相同，函数参数列表不同，这样的函数构成重载，与返回值类型无关。
1. 函数名相同，参数类型不同。
2. 函数名相同，参数个数不同。
3. 函数名相同，参数顺序不同。
4. 函数名相同，const修饰和非const修饰。

## 3.2 内联函数
1. 使用**inline**关键字修饰的函数叫内联函数。
2. 编译器将会尝试进行内联优化，用已编译好的二进制代码，替换对该函数的调用指令。
3. 效率和过程和宏函数有点像，与宏函数不同的是发生在编译阶段，不是预处理阶段。
4. 内联函数使可执行文件的体积和进程代码内存变大，**以空间换时间。**
5. 频繁调用的简单函数适合内联，稀少调用的复杂函数不适合内联。
6. **递归函数和虚函数不能内联。**
7. 内联函数是一种请求，最终是否内联，由编译器决定。

# 4. 动态内存分配
## 4.1 new动态分配内存
>int* pi = new int(66);

new数组：
>int* parr = new int[3]{1,2,3};

## 4.2 delete释放内存
不能通过delete操作符释放已释放过的内存。
>delete pi;<br>
>pi = NULL;

delete数组：
>delete[] parr;<br>
>parr = NULL;

# 5. 引用
## 5.1 概念
引用就是给变量起别名，引用可以做函数的参数和返回值。
>int a = 66;<br>
>int &b = a;

## 5.2 与指针的比较
1. 引用必须初始化，指针可以不初始化。
2. 引用不可以为空，指针可以。
3. 引用不可以更换目标，指针可以。
4. 不能声明引用数组，可以声明指针数组。
5. 可以定义指向指针的指针，不能定义指向引用的指针。
6. 可以定义指针的引用，不能定义引用的引用。

# 6. 面向对象
## 6.1 控制访问属性

## 6.2 构造函数

## 6.3 析构函数

## 6.4 this指针

# 7. 异常

# 8. I/O流