<!-- TOC -->

- [1. 输入输出和标准名字空间](#1-输入输出和标准名字空间)
    - [1.1 标准输入](#11-标准输入)
    - [1.2 标准输出](#12-标准输出)
    - [1.3 标准名字空间](#13-标准名字空间)
- [2. 数据类型](#2-数据类型)
    - [2.1 字符串](#21-字符串)
    - [2.2 类型转换](#22-类型转换)
        - [2.2.1 隐式类型转换](#221-隐式类型转换)
        - [2.2.2 强制类型转换](#222-强制类型转换)
- [3. 函数](#3-函数)
    - [3.1 函数重载](#31-函数重载)
    - [3.2 内联函数](#32-内联函数)
- [4. 动态内存分配](#4-动态内存分配)
    - [4.1 new动态分配内存](#41-new动态分配内存)
    - [4.2 delete释放内存](#42-delete释放内存)
- [5. 引用](#5-引用)
    - [5.1 概念](#51-概念)
    - [5.2 与指针的比较](#52-与指针的比较)
    - [5.3 常引用](#53-常引用)
- [6. 类Class](#6-类class)
    - [6.1 控制访问属性](#61-控制访问属性)
    - [6.2 类的多文件编译](#62-类的多文件编译)
    - [6.3 构造函数](#63-构造函数)
        - [6.3.1 构造函数的重载和缺省构造函数](#631-构造函数的重载和缺省构造函数)
        - [6.3.2 自定义类型转换构造函数](#632-自定义类型转换构造函数)
        - [6.3.3 拷贝构造函数](#633-拷贝构造函数)
        - [6.3.4 初始化列表](#634-初始化列表)
    - [6.4 this指针](#64-this指针)
    - [6.5 const成员函数和mutable关键字](#65-const成员函数和mutable关键字)
    - [6.6 析构函数](#66-析构函数)
    - [6.7 拷贝赋值函数](#67-拷贝赋值函数)
    - [6.8 static成员](#68-static成员)
        - [6.8.1 static成员变量](#681-static成员变量)
        - [6.8.2 static成员函数](#682-static成员函数)
        - [6.8.3 单例模式](#683-单例模式)
- [7. 继承](#7-继承)
    - [7.1 继承特性](#71-继承特性)
    - [7.2 多重继承和虚继承](#72-多重继承和虚继承)
    - [7.3 多态和虚函数](#73-多态和虚函数)
    - [7.4 纯虚函数和抽象类](#74-纯虚函数和抽象类)
- [8. 异常](#8-异常)
    - [8.1 异常语法](#81-异常语法)
    - [8.2 异常基本用法](#82-异常基本用法)
    - [8.3 函数的异常说明](#83-函数的异常说明)

<!-- /TOC -->
# 1. 输入输出和标准名字空间
## 1.1 标准输入 
>cin >> a >> b; //scanf("%d%d\n",&a,&b);

## 1.2 标准输出 
>cout << a << b << endl; //printf("%d%d\n",a,b);

**endl类似'\n'。**

## 1.3 标准名字空间
1. **std::** 表示标准名字空间，使用**namespace**关键字定义名字空间。
2. 名字空间成员可以是全局变量，函数，类型，名字空间：
>namespace 名字空间名字{<br>
    int g_num=0; // 全局变量<br> 
    void fun(){} // 函数<br>
    struct Student{}; //结构体类型<br>
    namespace 名字空间{} // 名字空间嵌套<br>
}
3. 使用名字空间指令，可以全局使用名字空间里的成员，调用成员时，不需要显示声明**std::**。
>using namespace 名字空间名字;

# 2. 数据类型
## 2.1 字符串 
1. 初始化：
    >- string s1 = "hello world";
    >- string s2(s1);
2. 获取字符串长度：
    >- size_t size();//长度不包含'\0'
    >- size_t lenght();//本质和上面一样
3. 转换为C风格的字符串：
    >- const char* c_str();
4. 交换字符串：
    >- void swap(string s1,string s2);

## 2.2 类型转换 
### 2.2.1 隐式类型转换 
C++支持隐式类型转换，即由小转大。

### 2.2.2 强制类型转换
1. 静态类型转换：<br>
用于隐式转换的逆转换，常用于将void*转换为其它类型的指针。
>目标类型变量 = static_cast<目标类型>(源类型变量);
2. 常量类型转换：<br>
主要用于去除指针/引用上面的常量属性。
>目标类型变量 = const_cast<目标类型>(源类型变量);
3. 重解释类型转换：<br>
主要用于任意指针类型之间的转换，以及指针和整型之间的转换。
>目标类型变量 = reinterpret_cast<目标类型>(源类型变量);
4. 动态类型转换：<br>
主要用于具有多态特征的父子类指针/引用之间的转换。
>目标类型变量 = dynamic_cast<目标类型>(源类型变量);

# 3. 函数
## 3.1 函数重载
在同一个作用域内，函数名字相同，函数参数列表不同，这样的函数构成重载，与返回值类型无关。
1. 函数名相同，参数类型不同。
2. 函数名相同，参数个数不同。
3. 函数名相同，参数顺序不同。
4. 函数名相同，const修饰和非const修饰。

## 3.2 内联函数
1. 使用**inline**关键字修饰的函数叫内联函数。
2. 编译器将会尝试进行内联优化，用已编译好的二进制代码，替换对该函数的调用指令。
3. 效率和过程和宏函数有点像，与宏函数不同的是发生在编译阶段，不是预处理阶段。
4. 内联函数使可执行文件的体积和进程代码内存变大，**以空间换时间。**
5. 频繁调用的简单函数适合内联，稀少调用的复杂函数不适合内联。
6. **递归函数和虚函数不能内联。**
7. 内联函数是一种请求，最终是否内联，由编译器决定。

# 4. 动态内存分配
## 4.1 new动态分配内存
>int* pi = new int(66);

new数组：
>int* parr = new int[3]{1,2,3};

new对象：
>对象名* pclass = new 对象名(参数);<br>
>Student* p = new Student("张三");

new对象数组：
>对象名* pclass = new 对象名[3];<br>
>Student* parr = new Student[2]{Student("张三"),Student("李四")};

## 4.2 delete释放内存
不能通过delete操作符释放已释放过的内存。
>delete pi;<br>
>pi = NULL;

delete数组：
>delete[] parr;<br>
>parr = NULL;

# 5. 引用
## 5.1 概念
引用就是给变量起别名，引用可以做函数的参数和返回值。
>int a = 66;<br>
>int &b = a;<br>
>cout << b << endl;

## 5.2 与指针的比较
1. 引用必须初始化，指针可以不初始化。
2. 引用不可以为空，指针可以。
3. 引用不可以更换目标，指针可以。
4. 不能声明引用数组，可以声明指针数组。
5. 可以定义指向指针的指针，不能定义指向引用的指针。
6. 可以定义指针的引用，不能定义引用的引用。

## 5.3 常引用
>const int& a = b;<br>
>int const& a = b;//和上面等价

普通引用叫做左值引用，**常引用是万能引用**。<br>
普通引用指向右值(rvalue)会报错，如：
>int& r = 100;//报错

用const不会报错：
>const int& r = 100;

# 6. 类Class
## 6.1 控制访问属性
1. 不同的访问属性，影响类中成员访问的位置：
    - public，任何位置都可以访问。
    - protected，类内部和子类中可以访问。
    - private，只有类的内部才可以访问。
2. 缺省访问属性：
    - 使用class定义的类，缺省访问属性是private。
    - 使用struct定义的类，缺省访问属性是public。
    
## 6.2 类的多文件编译
类的声明和实现可以分开：<br>
**声明文件：**
>class Student{<br>
public:<br>
    &emsp;Student(const string& name, int age);<br>
    &emsp;void who();<br>
private:<br>
    &emsp;string m_name;<br>
    &emsp;int m_age;<br> 
};

**实现文件：**
>void Student::who(){<br>
    &emsp;cout << m_name << endl;<br>
}

**在实现文件中，要用类名::的方式限定作用域。**

## 6.3 构造函数
### 6.3.1 构造函数的重载和缺省构造函数
1. 一个函数名和类名完全相同，并且没有返回值（连void都没有）的函数叫做构造函数。
2. 对象创建时，系统自动调用。
3. 如果一个类中没有构造函数，系统会自动提供一个**缺省的无参构造函数。**
4. 构造函数可以重载，**即一个类中可以有多个构造函数**，参数不同。
>class Student{<br>
public:<br>
    &emsp;Student(void){}<br>
    &emsp;Student(const string& name, int age)<br>
    &emsp;{<br>
        &emsp;&emsp;m_name = name;<br>
        &emsp;&emsp;m_age = age;<br>
    &emsp;}<br>
private:<br>
    &emsp;string m_name;<br>
    &emsp;int m_age;<br>
};

### 6.3.2 自定义类型转换构造函数
1. 可以实现从源对象到目标对象的一个隐式转换。
2. **explicit关键字**可以告诉编译器，不支持隐式转换，必须使用显式转换。
>Student(const Person& person){}<br>

### 6.3.3 拷贝构造函数
1. 调用拷贝构造函数的时机：
    - 用已定义对象作为同类型对象的构造实参。
    - 以对象的形式向函数传递参数。
    - 从函数中返回对象（有时候会因编译优化而省略）。
2. 本质上还是一个构造函数，只是函数的参数是一个本类。
3. 如果没有显示定义拷贝构造函数，则会有个缺省拷贝函数。
4. **尽量避免或减少对象的拷贝，传递参数和返回值尽量使用引用。**
>Student(const Student& that){}<br>

### 6.3.4 初始化列表
1. **只有构造函数有初始化列表。**
2. 成员变量的初始化顺序和初始化列表中的顺序无关，而是取决于成员变量的声明顺序。
3. 初始化列表的必要性：
    - 如果类中包含常量或者引用的成员变量时。
    - 在子类中，显示的构造其基类部分。
>Student(const String& name,int age):m_name(name),m_age(age){}

>Student(const String& name,int age):Person(name,age){}

## 6.4 this指针
1. 类的每个成员函数（包括构造函数，析构函数）都有一个隐藏的指针型参数this，指向调用该成员函数的对象。
2. 从成员函数中返回调用对象自身（返回自引用），支持串联调用。**（重点掌握）**
>class Counter{<br>
public:<br>
    &emsp;Counter(void){}<br>
    &emsp;Counter& add()<br>
    &emsp;{<br>
        &emsp;&emsp;m_count++;<br>
        &emsp;&emsp;return *this;<br>
    &emsp;}<br>
private:<br>
    &emsp;int m_count;<br>
};<br><br>
int main(){<br>
    &emsp;Counter c;<br>
    &emsp;c.add().add();<br>
}

## 6.5 const成员函数和mutable关键字
1. 在成员函数的形参表之后，函数体之前加上const关键字，即为常函数。
>void Student::getName()const{}
2. **常函数中的this指针是常指针，所以不能在常函数中修改成员变量。**
>void Student::getName()const{}//编译前<br>
>void Student::getName(const Student* this){}//编译后
3. **被声明为mutable的成员变量可以在const成员函数中被修改。**
>mutable int m_age(){}
4. const成员函数和非const成员函数构成重载。

## 6.6 析构函数
1. 当一个对象在销毁时会自动调用一个函数，这个函数名和类名相同（前面拥有～），**析构函数没有参数和返回值**，这样的函数是析构函数：
>～Student(void){}
2. **因为没有参数，所以不能构成重载。**
3. 如果类中没有自定义析构函数，那么系统会自动提供一个缺省构造函数，该析构函数会自动调用成员变量基类的析构函数，即：<br>
假设有A和B类，A类作为B类的成员变量，则先构造A，再构造B，再析构B，再析构A。

## 6.7 拷贝赋值函数
1. 拷贝赋值函数**不是构造函数。**
>Student& operator=(const Student& s){<br>
    &emsp;if(&s != this){}//防止自赋值<br>
}
2. 如果类中没有自定义拷贝赋值运算符函数，那么系统会自动提供一个缺省拷贝赋值函数。

## 6.8 static成员
### 6.8.1 static成员变量
1. 同一个类可以创建多个对象，每个对象都分别有一份自己的成员，内存上各自独立，互不相干，但很多适合希望某个成员可以为所有对象共有，内存唯一，这样可以实现数据共享。
2. 在传统的C语言中，可以通过全局变量实现数据共享，在程序的任何位置可以访问全局变量，但是全局变量安全性得不到保证，随处都可以修改全局变量，不利于程序的维护。
3. C++希望通过一个被局限在类中使用的全局资源，来实现该类所以对象的数据共享。
4. 被static修饰的变量即为静态成员变量：
>class Student{<br>
>static int a;<br>
}
5. **static成员变量必须在类外部单独定义：**
>int Student::a=0;<br>
6. 静态成员变量属于类，非静态成员变量属于对象，**即可以把静态成员变量理解为限制在类中使用的全局变量。**
7. **sizeof计算类的大小时，不包括静态成员变量的大小。**

### 6.8.2 static成员函数
1. **静态成员函数没有this指针**，因为static中的变量任何对象都可以共享，所以没有固定地址。
2. **静态成员函数只能访问静态成员（因为没有this指针，不能访问普通的成员变量和函数）。**
3. 非静态成员函数可以访问静态成员变量。
4. **静态成员函数没有this指针，所有没有const属性**，不能用const修饰。

### 6.8.3 单例模式
这个类只能实例化一个对象。
>class Single{<br>
private://1. 私有化构造函数，不允许用户通过类创建类对象<br>
    &emsp;Single(){};<br>
    &emsp;Single(const Single& s){};<br>
    &emsp;Single& operatpr=(const Single& s){};<br>
private:<br>
    &emsp;//2. 加上static表示这只是静态变量的声明，所以编译器不会报错<br>
    &emsp;static Single s_sig;<br>
public://3. 声明静态函数，可以不需要创建对象就可以访问单例对象<br>
    &emsp;static Single getSingle(void){<br>
        &emsp;&emsp;return s_sig;<br>
    &emsp;}<br>
};<br>
Single::s_sig;//在类外面定义<br><br>
int main(){<br>
    &emsp;Single s1 = Single::getSingle();<br>
    &emsp;Single s2 = Single::getSingle();//上下两个变量地址一样，也就是只有一个对象。<br>
}

# 7. 继承
## 7.1 继承特性
1. 继承方式有public，protected，private，**一般开发都采用public继承方式**：
>class Student:public Person{}<br>
2. **如果在子类定义一个与基类同名的函数，子类中的函数会隐藏基类的函数。**
3. 子类构造函数会先构造基类，再构造子类。
4. 子类析构函数会先析构子类，再析构基类。

## 7.2 多重继承和虚继承
1. 多重继承语法：
>class Phone:public Camera,public Music{}<br>
2. **钻石继承**指的是一个子类继承多个基类，多个基类又源自共同的公共基类。
3. 公共基类里的变量继承给多个子类，如果某个子类再继承公共基类的子类，则公共基类里的变量在最终子类里，是会有多份存在的，这会导致数据不一致，想要解决这种现象，可以使用**虚继承。**
4. **虚继承**语法：
>class Phone:virtual public Camera{}<br>
5. **虚继承**使公共基类里的变量在最终子对象中只有一份。

## 7.3 多态和虚函数
1. **多态**即，用基类指针/引用指向子类对象，通过基类指针/引用调用基类里的**虚函数**，实际上调用的是子类中和基类虚函数同名的函数。
2. **虚函数**语法：
>virtual void show(void){}
3. 对于基类中的**虚函数**来说，如果在子类中定义了一个与基类函数原型相同的函数，构成**虚函数覆盖**，该虚函数的覆盖版本也是一个虚函数。
4. **一般而言，如果一个类中有虚函数，则有可能构成多态，那么该类就应该提供一个虚析构函数。**
5. **虚析构函数**语法：
>virtual ～A(void){}
6. **虚析构函数**实际上就是保证delete一个指向子类的基类指针时，实际被调用的是子类中的析构函数，而该函数又会调用基类中的析构函数，从而避免内存泄露。
7. 在多态关系的父子类中，可以通过 **typeid()** 正确判断一个指针实际指向的对象类型。

## 7.4 纯虚函数和抽象类
1. 没有具体功能，即只声明不定义的函数叫**纯虚函数**：
>virtual void A(void)=0;
2. 至少有一个纯虚函数的类叫做**抽象类，抽象类是不能实例化对象的。**
3. 完全由纯虚函数组成的类叫做**纯抽象类。**
4. **如果一个抽象类的子类没有为该类中的全部纯虚函数提供覆盖版本，那么该子类也是抽象类。**

# 8. 异常
## 8.1 异常语法
1. 抛出异常：
>throw 异常类型;<br>
2. 捕获异常：
>try{//可能发生异常的代码}<br>
>catch(异常类型1){//针对异常类型1的处理}<br>
>catch(异常类型2){//针对异常类型2的处理}<br>

## 8.2 异常基本用法
1. 抛出简单的数据类型（int，char等），使用异常变量的数值来区分异常。
>throw -1;<br>
>catch(-1){}
2. 抛出自定义类类型异常对象，通过异常类型来区分不同异常。
>throw FileError(__FILE__,__LINE__);<br>
>catch(FileError& ex){}
3. 抛出标准异常类或者从标准异常类继承的类，标准C++库中使用exception类专门表示异常。

## 8.3 函数的异常说明
1. 用于说明函数可能抛出的异常类型，给函数调用者看，让函数调用者知道该函数可能会产生哪些异常：
>void fun(void) throw(异常类型1,异常类型2...){}
2. 函数异常是一种承诺，表示该函数抛出的异常不会超出说明范围，如果不遵守承诺抛出了异常说明以外的类型，则无法被正常捕获，导致进程终止。
3. 函数异常说明的两种极端形式：
    - 不写异常说明，表示可以抛出任何异常。
    - 空异常说明，throw()，表示不会抛出任何异常。

